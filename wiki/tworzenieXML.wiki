<wiki:toc max_depth="5" />
= Tworzenie XML =
== Minimalna zawartość ==
Plik konfiguracyjny *musi* nazywać się configuration.xml. Jego minimalna struktura to:

{{{
<?xml version="1.0" encoding="UTF-8"?>

<config>
</config>
}}}
Jak widać nie ma tego dużo jednak też system nie będzie zbyt funkcjonalny przy takim ustawieniu :)
== Parametry ==
Pliki xml są automatyczne cachowane przez system, co może być niewygodne na etapie ich pisania. Możemy to naprawić dodając parametr `cache`:
{{{
<?xml version="1.0" encoding="UTF-8"?>

<config>
    <parameters>
        <param name="cache">false</param>
    </parameters>
</config>
}}}
== Pasek startu ==
Definicja struktury paska startu mieści się w gałęzi `<interface>/<main-menu>` i może być dowolnie głęboko zagnieżdżana. Każda pozycja musi zawierać niepowtarzalne id, text oraz ikonkę.
{{{
<?xml version="1.0" encoding="UTF-8"?>

<config>
    <parameters>
        <param name="cache">false</param>
    </parameters>
    <interface>
        <main-menu>
            <item id="id1" text="etykieta_1" img="new.gif">
                <item id="id2" text="etykieta_2" img="new.gif" />
                <item id="id3" text="etykieta_3" img="new.gif" />
                <item id="id4" text="etykieta_4" img="new.gif" />
            </item>
        </main-menu>
    </interface>
</config>
}}}
== Okna ==
Teraz dobrze by było przypiąć pod te pozycje jakieś okienka:
{{{
<?xml version="1.0" encoding="UTF-8"?>

<config>
    <parameters>
        <param name="cache">false</param>
    </parameters>
    <interface>
        <main-menu>
            <item id="id1" text="etykieta_1" img="new.gif">
                <item id="id2" text="etykieta_2" img="new.gif" />
                <item id="id3" text="etykieta_3" img="new.gif" />
                <item id="id4" text="etykieta_4" img="new.gif" />
            </item>
        </main-menu>
    </interface>
    <windows>
        <window id="id2">
            <title>tytuł okna 1</title>
            <pos_x>100</pos_x>
            <pos_y>100</pos_y>
            <height>500</height>
            <width>500</width> 
            <content>
                <html>zawartość okna 1</html>
            </content>
        </window>
        <window id="id3">
            <title>tytuł okna 2</title>
            <content>
                <html>zawartość okna 2</html>
            </content>
        </window>
    </windows>
</config>
}}}
ID okna musi być takie samo jak ID przycisku z menu. Parametry tytułu, rozmieszczenia i rozmiaru są nieobowiązkowe.
== Dzielenie pliku ==
W związku z tym, że plik konfiguracyjny zaczyna się rozrastać, dostępny jest tag `<include path="<path>" />`, który można wykorzystać w dowolnym miejscu. np.:

`configuration.xml:`
{{{
<?xml version="1.0" encoding="UTF-8"?>

<config>
    <parameters>
        <param name="cache">false</param>
    </parameters>
    <interface>
        <main-menu>
            <item id="id1" text="etykieta_1" img="new.gif">
                <item id="id2" text="etykieta_2" img="new.gif" />
                <item id="id3" text="etykieta_3" img="new.gif" />
                <item id="id4" text="etykieta_4" img="new.gif" />
            </item>
        </main-menu>
    </interface>
    <windows>
        <include path="windows.xml" />
    </windows>
}}}
`windows.xml:`
{{{
<?xml version="1.0" encoding="UTF-8"?>
<windows>
    <window id="id2">
        <title>tytuł okna 1</title>
        <pos_x>100</pos_x>
        <pos_y>100</pos_y>
        <height>500</height>
        <width>500</width> 
        <content>
            <html>zawartość okna 1</html>
        </content>
    </window>
    <window id="id3">
        <title>tytuł okna 2</title>
        <content>
            <html>zawartość okna 2</html>
        </content>
    </window>
</windows>
}}}
Korzeń dołączanego pliku może mieć dowolną nazwę jednak zalecam używania nazwy węzła nadrzędnego. W dalszej części tego tutoriala będę trzymał wszystko w jednym pliku, pamiętaj jednak, że taga `<include>` możesz użyć w dowolnym miescu, ścieżka jest względna od katalogu `/htdoc/autowebsys/xmls`.
== Tagi ==
Zanim przejdziemy dalej, trzeba wprowadzić nową strukturę: krótkie tagi.

Jednym z ich zastosowań jest wykorzystanie mechanizmu internacjonalizacji, tak żeby na podstawie języka zgłoszonego przez przeglądarkę, użytkownik dostał swój zestaw etykiet. Tagi umieszczane są wewnątrz `{` `}`. Tag translacji wygląda następująco: `{translator:<etykieta>}` i może wystąpić w dowolnym miejscu pliku konfiguracyjnego:
{{{
<?xml version="1.0" encoding="UTF-8"?>

<config>
    <parameters>
        <param name="cache">false</param>
    </parameters>
    <interface>
        <main-menu>
            <item id="id1" text="{translator:E1}" img="new.gif">
                <item id="id2" text="{translator:E2}" img="new.gif" />
                <item id="id3" text="{translator:E3}" img="new.gif" />
                <item id="id4" text="{translator:E4}" img="new.gif" />
            </item>
        </main-menu>
    </interface>
    <windows>
        <window id="id2">
            <title>{translator:TITLE_1}</title>
            <pos_x>100</pos_x>
            <pos_y>100</pos_y>
            <height>500</height>
            <width>500</width> 
            <content>
                <html>{translator:CONTENT_1}</html>
            </content>
        </window>
    </windows>
</config>
}}}
Etykiety są wyszukiwane zgodnie z opisem w artykule [Internacjonalizacja].
== Szablony ==
Każdy system zawiera pewne powtarzalne elementy, dlatego też warto wydzielić mechanizm dla szablonów. To jak go użyć, jest opisane w dalszej części tego tutoriala. Formularze mieszczą się w gałęzi `<templates>` a ich struktura wygląda tak:
{{{
<templates>
    <temaplate>
        <name>user_form_template</name>
        <html>
            <!-- dowolny kod html -->
        </html>
    </template>
</templates>
}}}
== Konfiguracja bazy danych ==
Jako, że większość systemów wymaga dostępu do bazy danych, możliwość ta jest dostępna również tutaj. W celu konfiguracji bazy należy dodać nową gałąź do pliku konfiguracyjnego:
{{{
<config>
    <data>
        <datasource url="mysql:host=127.0.0.1;dbname=autowebsys" user="autowebsys" password="AUTO#web.sys" />
        <queries>
            ...
        </queries>
    </data>
    ...
</config>
}}}
Obsługa baz danych zaimplementowana jest w oparciu o [http://php.net/manual/en/book.pdo.php PHP PDO]. Parametr URL to `connection string` zgodny z PDO.
== Biblioteka zapytań SQL ==
Zanim wprowadzimy bardziej złożone kontrolki, opiszę bibliotekę zapytań. W celu podniesienie bezpieczeństwa aplikacji, wszystkie zapytania do DB zgromadzone są w pliku konfiguracyjnym a użytkownicy końcowi mogą się odwoływać do tych zapytań na podstawie ich nazwy. Pozwala to uniknąć ataku typu `SQL injection`. Pliki zapytań zgromadzone są w gałęzi `<queries>`:
{{{
<queries>
    <query name="user_select_by_id">SELECT * FROM user WHERE id = :id</query>
    <query name="user_select">SELECT * FROM user</query>
    <query name="user_update">UPDATE user SET extension = :extension, username = :username, balance = :balance WHERE id = :id</query>
    <query name="user_delete">DELETE FROM user WHERE id = :id</query>
    <query name="user_insert">INSERT INTO user(extension, username, balance) VALUES(:extension, :username, :balance)</query>
</queries>
}}}
Jak widać pytania są sparametryzowane, każdy parametr poprzedzony jest znakiem `:` a po nim następuje nazwa kolumny.
== Standardowe modele SQL ==
Niewiele by było pożytku z okien ze statyczną zawartością, dodajmy zatem tabelki. Żeby to zrobić, musimy wprowadzić nową gałąź konfiguracji: `<models>`. Każda złożona kontrolka(tabelka czy formularz) wymaga zestawu dodatkowych parametrów.
=== Formularze ===
Czas już najwyższy wprowadzić jakąś konkretną kontrolkę, zacznijmy od formularzy:
{{{
<models>
    <model>
        <name>user_edit_form</name>
        <type>sql</type>
        <template>user_form_template</template>
        <sql>
            <insert>user_insert</insert>
            <select>user_select_by_id</select>
            <update>user_update</update>
            <id>id</id>
            <columns>extension,username,balance</columns>
        </sql>
        <onSave>application.register.refresh('users_grid');</onSave>
    </model>
</models>
}}}
Każdy model musi posiadać unikalną nazwę. Tag `<type>` definiuje rodzaj formularza, póki co, załóżmy że musi to być sql. Tag `<template>` to odwołanie do szablonu formularza, czyli tego jak on będzie wyglądać(więcej za chwilę). Gałąź `<sql>` dostarcza informacji o sposobie komunikowania się modelu z bazą danych. Wartości tagów `<select>`, `<update>` oraz `<delete>` to nazwy zapytań. Tag `<id>` to nazwa kolumny identyfikatora, tag `<columns>` to nazwy kolumn, których dotyczą operacje CRUD.
Tag `<onSave>` zawiera kod JS, który zostanie wywołany po zapisaniu formularza. Konstrukcja, która jest w powyższym przykładzie wywoła odświeżenie wszystkich otwartych tabelek o nazwie modelu `users_grid` i narazie na tym poprzestańmy :)

Wracając do szablonów, w przypadku formularzy można zaprojektować dowolny wygląd formularza używając standardowych tagów HTML rozszerzonych o kilka dodatkowych atrybutów:
{{{
<templates>
    <template>
        <name>user_form_template</name>
        <html>
            <div>
                <fieldset>
                    <legend>{translator:USER_FORM_TITLE}</legend>
                    <table>
                        <tr>
                            <td style="width: 150px">{translator:FORM_USER_LABEL_EXTENSION}</td>
                            <td style="width: 100%;">
                                <input type="text" id="user_form_extension" bind="extension" validate="NotEmpty,ValidInteger,isExtensionUnique" style="width: 100%;" />
                            </td>
                        </tr>
                        <tr>
                            <td style="width: 150px">{translator:FORM_USER_LABEL_USERNAME}</td>
                            <td style="width: 100%;">
                                <input type="text" id="user_form_username" bind="username" validate="NotEmpty,isUsernameUnique" style="width: 100%;" />
                            </td>
                        </tr>
                        <tr>
                            <td style="width: 150px">{translator:FORM_USER_LABEL_BALANCE}</td>
                            <td style="width: 100%;">
                                <input type="text" id="user_form_balance" bind="balance" validate="NotEmpty,ValidNumeric" style="width: 100%;" />
                            </td>
                        </tr>
                        <tr>
                            <td colspan="2" style="width: 100%;">
                                <input type="hidden" id="user_form_id" bind="id" style="width: 100%;" />
                                <input type="button" id="save" value="{translator:FORM_USER_LABEL_SUBMIT}" />
                            </td>
                        </tr>
                    </table>
                </fieldset>
            </div>
        </html>
    </template>
</templates>
}}}
Atrybut `bind` wskazuje na nazwę atrybutu tabeli z bazy danych, z którym pole ma być związane. atrybut 'validate' pozwala na wskazanie nazw walidatorów kontrolujących poprawność danych. Można podać dowolną ilość walidatorów oddzielonych przecinkiem. Więcej [JSValidators w tym artykule].
=== Tabelka ===
Poniżej prezentuję minimalną konfigurację tabelki
{{{
<models>
    <model>
        <name>users_grid</name>
        <type>sql</type>
        <sql>
            <select>user_select</select>
            <update>user_update</update>
            <delete>user_delete</delete>
            <id>id</id>
            <columns>extension,username,balance</columns>
        </sql>
        <js>
            <setHeader>{translator:USER_GRID_HEADERS}</setHeader>
        </js>
    </model>
</models>
}}}
Tagi `<name>`, `<type>` oraz `<sql>` mają takie samo znaczenie jak w przypadku formularzy.

Gałąź JS musi zawierać przynajmniej definicję nagłówków tabeli wymienionych po przecinku, w artykule [tagiJSdlaTabelki tagi JS dla tabelki] opisane są pozostałe tagi.
==== Pasek narzędzi dla tabelki ====
==== Internacjonalizacja tabelki ====
== Modele niestandardowe ==